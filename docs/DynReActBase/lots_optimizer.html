<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="img/favicon.ico" />
    <title>Lots optimizer - Dynreact Base</title>
    <link rel="stylesheet" href="css/theme.css" />
    <link rel="stylesheet" href="css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
        <link href="assets/_mkdocstrings.css" rel="stylesheet" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Lots optimizer";
        var mkdocs_page_input_path = "lots_optimizer.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="index.html" class="icon icon-home"> Dynreact Base
        </a>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="" href="../index.html">Back</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="index.html">General</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="cost_provider.html">Cost provider</a>
                </li>
              </ul>
              <ul class="current">
                <li class="toctree-l1 current"><a class="reference internal current" href="#">Lots optimizer</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#optimizationlistener-class">OptimizationListener class</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#dynreact.base.LotsOptimizer.OptimizationListener">OptimizationListener</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#dynreact.base.LotsOptimizer.OptimizationListener.update_iteration">update_iteration</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#lotsoptimizationstate-class">LotsOptimizationState class</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#dynreact.base.LotsOptimizer.LotsOptimizationState">LotsOptimizationState</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#dynreact.base.LotsOptimizer.LotsOptimizationState.__init__">__init__</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#lotsoptimizer-class">LotsOptimizer class</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#dynreact.base.LotsOptimizer.LotsOptimizer">LotsOptimizer</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#dynreact.base.LotsOptimizer.LotsOptimizer.__init__">__init__</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#dynreact.base.LotsOptimizer.LotsOptimizer.parameters">parameters</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#dynreact.base.LotsOptimizer.LotsOptimizer.state">state</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#dynreact.base.LotsOptimizer.LotsOptimizer.add_listener">add_listener</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#dynreact.base.LotsOptimizer.LotsOptimizer.remove_listener">remove_listener</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#lotsoptimizationalgo-class">LotsOptimizationAlgo class</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#dynreact.base.LotsOptimizer.LotsOptimizationAlgo">LotsOptimizationAlgo</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#dynreact.base.LotsOptimizer.LotsOptimizationAlgo.__init__">__init__</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#dynreact.base.LotsOptimizer.LotsOptimizationAlgo.heuristic_solution">heuristic_solution</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#dynreact.base.LotsOptimizer.LotsOptimizationAlgo.due_dates_solution">due_dates_solution</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#dynreact.base.LotsOptimizer.LotsOptimizationAlgo.create_instance">create_instance</a>
    </li>
    </ul>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="model.html">Model</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="snapshot_provider.html">Snapshot provider</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="longtermplanning.html">Long term planning</a>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Dynreact Base</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html" class="icon icon-home" aria-label="Docs"></a></li>
      <li class="breadcrumb-item active">Lots optimizer</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="lots-optimizer">Lots optimizer</h1>
<p>The LotsOptimizer module contains the interface specification for the mid-term planning
algorithm. It is possible to provide a custom implementation, but the DynReAct software
already contains an implementation (in the MidTermPlanning folder).</p>
<hr />
<h2 id="optimizationlistener-class">OptimizationListener class</h2>


<div class="doc doc-object doc-class">



<a id="dynreact.base.LotsOptimizer.OptimizationListener"></a>
    <div class="doc doc-contents first">







              <details class="quote">
                <summary>Source code in <code>dynreact\base\LotsOptimizer.py</code></summary>
                <pre class="highlight"><code class="language-python">class OptimizationListener:

    def update_solution(self, planning: ProductionPlanning, objective_value: float):
        pass

    def update_iteration(self, iteration_cnt: int, lots_cnt: int, objective_value: float) -&gt; bool:
        """
        :return: false to interrupt the iteration
        """
        return True</code></pre>
              </details>



  <div class="doc doc-children">









<div class="doc doc-object doc-function">


<h2 id="dynreact.base.LotsOptimizer.OptimizationListener.update_iteration" class="doc doc-heading">
            <code class="highlight language-python">update_iteration(iteration_cnt, lots_cnt, objective_value)</code>

</h2>


    <div class="doc doc-contents ">

        


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Returns:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
                  <code>bool</code>
              –
              <div class="doc-md-description">
                <p>false to interrupt the iteration</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
            <details class="quote">
              <summary>Source code in <code>dynreact\base\LotsOptimizer.py</code></summary>
              <pre class="highlight"><code class="language-python">def update_iteration(self, iteration_cnt: int, lots_cnt: int, objective_value: float) -&gt; bool:
    """
    :return: false to interrupt the iteration
    """
    return True</code></pre>
            </details>
    </div>

</div>



  </div>

    </div>

</div><hr />
<h2 id="lotsoptimizationstate-class">LotsOptimizationState class</h2>


<div class="doc doc-object doc-class">



<a id="dynreact.base.LotsOptimizer.LotsOptimizationState"></a>
    <div class="doc doc-contents first">
            <p class="doc doc-class-bases">
              Bases: <code><span title="typing.Generic">Generic</span>[<span title="dynreact.base.LotsOptimizer.P">P</span>]</code></p>







              <details class="quote">
                <summary>Source code in <code>dynreact\base\LotsOptimizer.py</code></summary>
                <pre class="highlight"><code class="language-python">class LotsOptimizationState(Generic[P]):

    def __init__(self, current_solution: ProductionPlanning[P], current_objective_value: float,
                 best_solution: ProductionPlanning[P], best_objective_value: float,
                 num_iterations: int=0,  # deprecated
                 history: list[float]|None = None,
                 parameters: dict[str, any]|None = None):
        self.current_solution: ProductionPlanning[P] = current_solution
        self.current_object_value: float = current_objective_value
        self.best_solution: ProductionPlanning[P] = best_solution
        self.best_objective_value: float = best_objective_value
        self.num_iterations: int = num_iterations
        "deprecated"
        self.history: list[float] = list(history) if history is not None else [best_objective_value, current_objective_value]
        self.parameters: dict[str, any]|None = parameters</code></pre>
              </details>



  <div class="doc doc-children">









<div class="doc doc-object doc-function">


<h2 id="dynreact.base.LotsOptimizer.LotsOptimizationState.__init__" class="doc doc-heading">
            <code class="highlight language-python">__init__(current_solution, current_objective_value, best_solution, best_objective_value, num_iterations=0, history=None, parameters=None)</code>

</h2>


    <div class="doc doc-contents ">

            <details class="quote">
              <summary>Source code in <code>dynreact\base\LotsOptimizer.py</code></summary>
              <pre class="highlight"><code class="language-python">def __init__(self, current_solution: ProductionPlanning[P], current_objective_value: float,
             best_solution: ProductionPlanning[P], best_objective_value: float,
             num_iterations: int=0,  # deprecated
             history: list[float]|None = None,
             parameters: dict[str, any]|None = None):
    self.current_solution: ProductionPlanning[P] = current_solution
    self.current_object_value: float = current_objective_value
    self.best_solution: ProductionPlanning[P] = best_solution
    self.best_objective_value: float = best_objective_value
    self.num_iterations: int = num_iterations
    "deprecated"
    self.history: list[float] = list(history) if history is not None else [best_objective_value, current_objective_value]
    self.parameters: dict[str, any]|None = parameters</code></pre>
            </details>
    </div>

</div>



  </div>

    </div>

</div><hr />
<h2 id="lotsoptimizer-class">LotsOptimizer class</h2>


<div class="doc doc-object doc-class">



<a id="dynreact.base.LotsOptimizer.LotsOptimizer"></a>
    <div class="doc doc-contents first">
            <p class="doc doc-class-bases">
              Bases: <code><span title="typing.Generic">Generic</span>[<span title="dynreact.base.LotsOptimizer.P">P</span>]</code></p>


        <p>Stateful optimization, remembers current best solution</p>






              <details class="quote">
                <summary>Source code in <code>dynreact\base\LotsOptimizer.py</code></summary>
                <pre class="highlight"><code class="language-python">class LotsOptimizer(Generic[P]):
    """
    Stateful optimization, remembers current best solution
    """

    def __init__(self, site: Site, process: str, costs: CostProvider, snapshot: Snapshot, targets: ProductionTargets,
                 # Note: we should accept None for the initial solution, for instances only used to assign lots
                 initial_solution: ProductionPlanning[P], min_due_date: datetime|None = None,
                 # the next two are for initialization from a previous optimization run
                 best_solution: ProductionPlanning[P]|None = None, history: list[float] | None = None,
                 parameters: dict[str, any]|None = None,
                 performance_models: list[PlantPerformanceModel]|None = None
                 ):
        self._listeners: list[OptimizationListener] = []
        self._site: Site = site
        self._process: str = process
        self._snapshot = snapshot
        self._costs: CostProvider = costs
        self._targets = targets
        self._min_due_date: datetime|None = min_due_date
        self._performance_models = [pm for pm in performance_models if process in pm.applicable_processes_and_plants()[0]] if performance_models is not None else None
        target_plants: list[int] = list(targets.target_weight.keys())
        assigned_plants: set[int] = set(ass.equipment for ass in initial_solution.order_assignments.values()) \
            if initial_solution is not None else set()
        status_plants = list(initial_solution.equipment_status.keys()) if initial_solution is not None else []
        zombie_plant_assigned: int|None = next((p for p in assigned_plants if p not in target_plants and p &gt;= 0), None)
        if zombie_plant_assigned is not None:
            raise Exception("Plant " + str(zombie_plant_assigned) + " has been assigned an order but has no defined target value")
        zombie_plant_status = next((p for p in status_plants if p not in target_plants), None)
        if zombie_plant_status is not None:
            raise Exception("Plant " + str(zombie_plant_status) + " has a status but no defined target value")
        self._plants: list[Equipment] = [site.get_equipment(p, do_raise=True) for p in target_plants]
        self._plant_ids: list[int] = target_plants
        invalid_plant = next((plant for plant in self._plants if plant.process != process), None)
        if invalid_plant is not None:
            raise Exception("Configured plant " + str(invalid_plant.name_short if invalid_plant.name_short is not None else invalid_plant.id)  \
                            + " belongs to process " + str(invalid_plant.process) + ", not " + process)
        self._orders: dict[str, Order]|None = None
        if initial_solution is not None:
            self._orders = {o: snapshot.get_order(o) for o in initial_solution.order_assignments.keys()}
        initial_costs = costs.process_objective_function(initial_solution) if initial_solution is not None else None
        best_costs = initial_costs if best_solution is None else costs.process_objective_function(best_solution)
        best_solution = initial_solution if best_solution is None else best_solution
        history = [initial_costs] if history is None else history
        # state
        self._state: LotsOptimizationState[P] = LotsOptimizationState(current_solution=initial_solution, best_solution=best_solution,
                                        current_objective_value=initial_costs, best_objective_value=best_costs, history=history, parameters=parameters)

    def parameters(self) -&gt; dict[str, any]|None:
        return self._state.parameters

    # side effects on state
    def run(self, max_iterations: int|None = None, debug: bool=False) -&gt; LotsOptimizationState[P]:
        raise Exception("Not implemented")

    def state(self) -&gt; LotsOptimizationState[P]:
        return self._state

    def assign_lots(self, order_plant_assignments: dict[str, int]) -&gt; dict[int, list[Lot]]:
        raise Exception("Not implemented")

    def update_transition_costs(self, plant: Equipment, current: Order, next: Order, status: EquipmentStatus, snapshot: Snapshot,
                                current_material: Material | None = None, next_material: Material | None = None) -&gt; tuple[EquipmentStatus, float]:
        """
        Note: this is intended to forward to the cost service, the lot optimizer only needs to determine whether this
        leads to a new lot or not
        """
        raise Exception("not implemented")

    def add_listener(self, listener: OptimizationListener):
        if listener not in self._listeners:
            self._listeners.append(listener)

    def remove_listener(self, listener: OptimizationListener):
        self._listeners.remove(listener)</code></pre>
              </details>



  <div class="doc doc-children">









<div class="doc doc-object doc-function">


<h2 id="dynreact.base.LotsOptimizer.LotsOptimizer.__init__" class="doc doc-heading">
            <code class="highlight language-python">__init__(site, process, costs, snapshot, targets, initial_solution, min_due_date=None, best_solution=None, history=None, parameters=None, performance_models=None)</code>

</h2>


    <div class="doc doc-contents ">

            <details class="quote">
              <summary>Source code in <code>dynreact\base\LotsOptimizer.py</code></summary>
              <pre class="highlight"><code class="language-python">def __init__(self, site: Site, process: str, costs: CostProvider, snapshot: Snapshot, targets: ProductionTargets,
             # Note: we should accept None for the initial solution, for instances only used to assign lots
             initial_solution: ProductionPlanning[P], min_due_date: datetime|None = None,
             # the next two are for initialization from a previous optimization run
             best_solution: ProductionPlanning[P]|None = None, history: list[float] | None = None,
             parameters: dict[str, any]|None = None,
             performance_models: list[PlantPerformanceModel]|None = None
             ):
    self._listeners: list[OptimizationListener] = []
    self._site: Site = site
    self._process: str = process
    self._snapshot = snapshot
    self._costs: CostProvider = costs
    self._targets = targets
    self._min_due_date: datetime|None = min_due_date
    self._performance_models = [pm for pm in performance_models if process in pm.applicable_processes_and_plants()[0]] if performance_models is not None else None
    target_plants: list[int] = list(targets.target_weight.keys())
    assigned_plants: set[int] = set(ass.equipment for ass in initial_solution.order_assignments.values()) \
        if initial_solution is not None else set()
    status_plants = list(initial_solution.equipment_status.keys()) if initial_solution is not None else []
    zombie_plant_assigned: int|None = next((p for p in assigned_plants if p not in target_plants and p &gt;= 0), None)
    if zombie_plant_assigned is not None:
        raise Exception("Plant " + str(zombie_plant_assigned) + " has been assigned an order but has no defined target value")
    zombie_plant_status = next((p for p in status_plants if p not in target_plants), None)
    if zombie_plant_status is not None:
        raise Exception("Plant " + str(zombie_plant_status) + " has a status but no defined target value")
    self._plants: list[Equipment] = [site.get_equipment(p, do_raise=True) for p in target_plants]
    self._plant_ids: list[int] = target_plants
    invalid_plant = next((plant for plant in self._plants if plant.process != process), None)
    if invalid_plant is not None:
        raise Exception("Configured plant " + str(invalid_plant.name_short if invalid_plant.name_short is not None else invalid_plant.id)  \
                        + " belongs to process " + str(invalid_plant.process) + ", not " + process)
    self._orders: dict[str, Order]|None = None
    if initial_solution is not None:
        self._orders = {o: snapshot.get_order(o) for o in initial_solution.order_assignments.keys()}
    initial_costs = costs.process_objective_function(initial_solution) if initial_solution is not None else None
    best_costs = initial_costs if best_solution is None else costs.process_objective_function(best_solution)
    best_solution = initial_solution if best_solution is None else best_solution
    history = [initial_costs] if history is None else history
    # state
    self._state: LotsOptimizationState[P] = LotsOptimizationState(current_solution=initial_solution, best_solution=best_solution,
                                    current_objective_value=initial_costs, best_objective_value=best_costs, history=history, parameters=parameters)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="dynreact.base.LotsOptimizer.LotsOptimizer.parameters" class="doc doc-heading">
            <code class="highlight language-python">parameters()</code>

</h2>


    <div class="doc doc-contents ">

            <details class="quote">
              <summary>Source code in <code>dynreact\base\LotsOptimizer.py</code></summary>
              <pre class="highlight"><code class="language-python">def parameters(self) -&gt; dict[str, any]|None:
    return self._state.parameters</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="dynreact.base.LotsOptimizer.LotsOptimizer.state" class="doc doc-heading">
            <code class="highlight language-python">state()</code>

</h2>


    <div class="doc doc-contents ">

            <details class="quote">
              <summary>Source code in <code>dynreact\base\LotsOptimizer.py</code></summary>
              <pre class="highlight"><code class="language-python">def state(self) -&gt; LotsOptimizationState[P]:
    return self._state</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="dynreact.base.LotsOptimizer.LotsOptimizer.add_listener" class="doc doc-heading">
            <code class="highlight language-python">add_listener(listener)</code>

</h2>


    <div class="doc doc-contents ">

            <details class="quote">
              <summary>Source code in <code>dynreact\base\LotsOptimizer.py</code></summary>
              <pre class="highlight"><code class="language-python">def add_listener(self, listener: OptimizationListener):
    if listener not in self._listeners:
        self._listeners.append(listener)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="dynreact.base.LotsOptimizer.LotsOptimizer.remove_listener" class="doc doc-heading">
            <code class="highlight language-python">remove_listener(listener)</code>

</h2>


    <div class="doc doc-contents ">

            <details class="quote">
              <summary>Source code in <code>dynreact\base\LotsOptimizer.py</code></summary>
              <pre class="highlight"><code class="language-python">def remove_listener(self, listener: OptimizationListener):
    self._listeners.remove(listener)</code></pre>
            </details>
    </div>

</div>



  </div>

    </div>

</div><hr />
<h2 id="lotsoptimizationalgo-class">LotsOptimizationAlgo class</h2>


<div class="doc doc-object doc-class">



<a id="dynreact.base.LotsOptimizer.LotsOptimizationAlgo"></a>
    <div class="doc doc-contents first">


        <p>Implementation expected in module dynreact.lotscreation.LotsOptimizerImpl</p>






              <details class="quote">
                <summary>Source code in <code>dynreact\base\LotsOptimizer.py</code></summary>
                <pre class="highlight"><code class="language-python">class LotsOptimizationAlgo:
    """
    Implementation expected in module dynreact.lotscreation.LotsOptimizerImpl
    """

    def __init__(self, site: Site):
        self._site = site

    # TODO clarify: should we consider the planning horizon here? =&gt; would need some information about planned lot execution time
    def snapshot_solution(self, process: str, snapshot: Snapshot, planning_horizon: timedelta, costs: CostProvider,
                                targets: ProductionTargets|None = None,
                                orders: list[str] | None = None,
                                include_inactive_lots: bool=False) -&gt; tuple[ProductionPlanning, ProductionTargets]:
        assignments: dict[str, OrderAssignment] = {}
        target_weights_by_plant: dict[int, float] = {}
        order_objs = snapshot.orders
        for plant_id, lots in snapshot.lots.items():
            plant = next((p for p in self._site.equipment if p.id == plant_id), None)
            if plant is None or plant.process != process or (targets is not None and plant.id not in targets.target_weight):
                continue
            weight_sum: float = 0.
            for lot in lots:
                if not lot.active and not include_inactive_lots:
                    continue
                for lot_idx, order_id in enumerate(lot.orders):
                    if orders is not None and order_id not in orders:
                        continue
                    assignments[order_id] = OrderAssignment(equipment=plant_id, order=order_id, lot=lot.id, lot_idx=lot_idx + 1)
                    order = next((o for o in order_objs if o.id == order_id), None)
                    if order is not None:
                        weight_sum += order.actual_weight
            target_weights_by_plant[plant_id] = weight_sum
        if orders is not None:
            unassigned: Sequence[str] = (order for order in orders if order not in assignments)
            assignments.update({order: OrderAssignment(order=order, equipment=-1, lot="", lot_idx=-1) for order in unassigned})
        targets: ProductionTargets = targets if targets is not None else \
            ProductionTargets(process=process, target_weight={p: EquipmentProduction(equipment=p, total_weight=weight) for p, weight in target_weights_by_plant.items()},
                              period=(snapshot.timestamp, snapshot.timestamp + planning_horizon))
        planning = costs.evaluate_order_assignments(process, assignments, targets=targets, snapshot=snapshot) if costs is not None else None
        return planning, targets

    def heuristic_solution(self, process: str, snapshot: Snapshot, planning_horizon: timedelta, costs: CostProvider,
                           targets: ProductionTargets, orders: list[str], start_orders: dict[int, str]|None=None) -&gt; tuple[ProductionPlanning, ProductionTargets]:
        """
        If orders is not specified, this method will only consider as many orders for scheduling as are required to
        fulfill the targets per plant. Otherwise unassigned orders may occur.
        :param process:
        :param snapshot:
        :param planning_horizon:
        :param costs:
        :param targets:
        :param orders:
        :param start_orders: keys: plant id, values: order
        :return:
        """
        # We remove orders from this dict as they are assigned to plants
        order_objects: dict[str, Order] = {order.id: order for order in snapshot.orders if order.id in orders}
        # for faster access, remember assigned orders
        orders_done: dict[str, Order] = {}
        # We remove plants from this list as soon as there are no more orders available for them (by checking available_tons_per_plant[plant] &gt; 0)
        plants: dict[int, Equipment] = {p.id: p for p in self._site.get_process_equipment(process) if p.id in targets.target_weight}
        #assignments: dict[str, int] = {}
        assignments_by_plant: dict[int, list[str]] = {p: [] for p in plants.keys()}
        plant_weights: dict[int, float] = {}
        if start_orders is None:
            start_orders = {}
        # Here we keep track of available tons (from as yet unassigned orders) per plant
        available_tons_by_plant: dict[int, float] = {p: 0 for p in plants.keys()}
        # here we keep track of how many tons are still missing per plant
        missing_tons_by_plant: dict[int, float] = {p: targets.target_weight[p].total_weight for p in plants.keys()}
        for order in order_objects.values():
            orders_plants = [p for p in plants.keys() if p in order.allowed_equipment]
            for p in orders_plants:
                available_tons_by_plant[p] += order.actual_weight
                # TODO better initialization algo?

        def assign_to_plant(o: Order, plant: int):
            assignments_by_plant[plant].append(o.id)
            order_objects.pop(o.id)
            orders_done[o.id] = o
            missing_tons_by_plant[plant] = missing_tons_by_plant[plant] - o.actual_weight
            for other_plant in o.allowed_equipment:
                if other_plant in available_tons_by_plant:
                    available_tons_by_plant[other_plant] = available_tons_by_plant[other_plant] - o.actual_weight

        for plant in [p for p in plants.keys() if p not in start_orders]:
            random_order: Order | None = next((o for o in order_objects.values() if plant in o.allowed_equipment), None)
            if random_order is not None:
                start_orders[plant] = random_order.id
                assign_to_plant(random_order, plant)
            else:
                plants.pop(plant)
        # The main loop
        while len(plants) &gt; 0 and len(order_objects) &gt; 0:
            diff_by_plant: dict[int, float] = {p: available_tons_by_plant[p] - missing_tons_by_plant[p] for p in plants.keys()}
            plant: int = min(diff_by_plant, key=diff_by_plant.get) # the plant most in need of more orders
            if available_tons_by_plant[plant] &lt; 0.00001:
                plants.pop(plant)
                continue
            plant_obj: Equipment = plants[plant]
            current_order: str = assignments_by_plant[plant][-1] if len(assignments_by_plant[plant]) &gt; 0 else start_orders[plant]
            current_order_obj: Order = orders_done[current_order] if current_order in orders_done else snapshot.get_order(current_order, do_raise=True)
            # applicable_orders = {oid: order for oid, order in order_objects.items() if plant in order.allowed_plants}
            transition_costs: dict[str, float] = \
                {oid: costs.transition_costs(plant_obj, current_order_obj, order) for oid, order in order_objects.items() if plant in order.allowed_equipment}
            applicable_orders_cnt: int = len(transition_costs)
            transition_costs: dict[str, float] = {oid: cost for oid, cost in transition_costs.items() if np.isfinite(cost)}
            if len(transition_costs) == 0:  # ideally this should not happen
                if applicable_orders_cnt &gt; 0:
                    print("No valid transition to a new order found for plant", plant.id, "out of", applicable_orders_cnt, "applicable orders")
                plants.pop(plant)
                continue
            lowest_transition_order: str = min(transition_costs, key=transition_costs.get)
            assign_to_plant(order_objects[lowest_transition_order], plant)
            if missing_tons_by_plant[plant] &lt; 0.01:  # TODO configurable threshold
                plants.pop(plant)
        # keys: orders, values: plants
        assignments: dict[str, int] = {order: plant for plant, orders in assignments_by_plant.items() for order in orders}

        instance = self._create_instance_internal(process, snapshot, targets, costs, None)
        plant_lots: dict[int, list[Lot]] = instance.assign_lots(assignments)
        order_assignments: dict[str, OrderAssignment] = {}
        for order, plant in assignments.items():
            if plant not in plant_lots:
                continue
            lots = plant_lots[plant]
            lot: Lot | None = next((lot for lot in lots if order in lot.orders), None)
            if lot is None:
                continue
            order_assignments[order] = OrderAssignment(order=order, equipment=plant, lot=lot.id,
                                                       lot_idx=lot.orders.index(order) + 1)
        if orders is not None:
            unassigned: Sequence[str] = (order for order in orders if order not in assignments)
            order_assignments.update(
                {order: OrderAssignment(order=order, equipment=-1, lot="", lot_idx=-1) for order in unassigned})
        planning = costs.evaluate_order_assignments(process, order_assignments, targets=targets, snapshot=snapshot)
        return planning, targets


    def due_dates_solution(self, process: str, snapshot: Snapshot, planning_horizon: timedelta, costs: CostProvider,
                           targets: ProductionTargets|None = None, orders: list[str] | None = None,
                           include_inactive_lots: bool=False) -&gt; tuple[ProductionPlanning, ProductionTargets]:
        """
        If orders is not specified, this method will only consider as many orders for scheduling as are required to
        fulfill the targets per plant. Otherwise unassigned orders may occur.
        :param process:
        :param snapshot:
        :param planning_horizon:
        :param costs:
        :param targets:
        :param orders:
        :return:
        """
        if targets is None:  # TODO long term planning targets?
            _, targets = self.snapshot_solution(process, snapshot, planning_horizon, None, include_inactive_lots=include_inactive_lots)
        orders_sorted: list[Order] = sorted([o for o in snapshot.orders if o.due_date is not None and
                                             (orders is None or o.id in orders)], key=lambda order: order.due_date)
        #assignments: dict[str, OrderAssignment] = {}
        assignments: dict[str, int] = {}
        plant_weights: dict[int, float] = {}
        plants: list[int] = [p.id for p in self._site.get_process_equipment(process) if p.id in targets.target_weight]
        for order in orders_sorted:
            # TODO filter orders eligible for the current process stage =&gt; non-trivial!
            next_eligible_plant: int|None = next((p for p in order.allowed_equipment if p in plants and
                                                  (p not in plant_weights or (p in targets.target_weight and plant_weights[p] &lt; targets.target_weight[p].total_weight))), None)
            if next_eligible_plant is None:
                # TODO check if all plant target weights are already exhausted, then break
                continue
            if next_eligible_plant not in plant_weights:
                plant_weights[next_eligible_plant] = 0
            plant_weights[next_eligible_plant] = plant_weights[next_eligible_plant] + order.actual_weight
            assignments[order.id] = next_eligible_plant # OrderAssignment(order=order.id, plant=next_eligible_plant, lot=..., lot_idx=...)
        instance = self._create_instance_internal(process, snapshot, targets, costs, None)
        plant_lots: dict[int, list[Lot]] = instance.assign_lots(assignments)
        order_assignments: dict[str, OrderAssignment] = {}
        for order, plant in assignments.items():
            if plant not in plant_lots:
                continue
            lots = plant_lots[plant]
            lot: Lot|None = next((lot for lot in lots if order in lot.orders), None)
            if lot is None:
                continue
            order_assignments[order] = OrderAssignment(order=order, equipment=plant, lot=lot.id, lot_idx=lot.orders.index(order)+1)
        if orders is not None:
            unassigned: Sequence[str] = (order for order in orders if order not in assignments)
            order_assignments.update({order: OrderAssignment(order=order, equipment=-1, lot="", lot_idx=-1) for order in unassigned})
        planning = costs.evaluate_order_assignments(process, order_assignments, targets=targets, snapshot=snapshot)
        return planning, targets

    def create_instance(self, process: str, snapshot: Snapshot, cost_provider: CostProvider,
                        targets: ProductionTargets | None = None, initial_solution: ProductionPlanning | None = None,
                        min_due_date: datetime|None = None,
                        # optionally, specify the orders to be planned explicitly
                        # TODO option to specify the urgency(?)
                        orders: list[str]|None = None,
                        # the next two are for initialization from a previous optimization run
                        best_solution: ProductionPlanning[P] | None = None, history: list[float] | None = None,
                        performance_models: list[PlantPerformanceModel] | None = None,
                        parameters: dict[str, any] | None = None,
                        include_inactive_lots: bool = False
                        ) -&gt; LotsOptimizer:
        if initial_solution is None or targets is None:
            planning_horizon = targets.period[1] - targets.period[0] if targets is not None else timedelta(hours=8)  # XXX?
            initial_solution0, targets0 = self.snapshot_solution(process, snapshot, planning_horizon, cost_provider, targets=targets,
                                                                 orders=orders, include_inactive_lots=include_inactive_lots)
            if initial_solution is None:
                initial_solution = initial_solution0
            if targets is None:
                targets = targets0
        return self._create_instance_internal(process, snapshot, targets, cost_provider, initial_solution, min_due_date=min_due_date,
                                              best_solution=best_solution, history=history, parameters=parameters, performance_models=performance_models)

    def _create_instance_internal(self, process: str, snapshot: Snapshot, targets: ProductionTargets,
                                  cost_provider: CostProvider, initial_solution: ProductionPlanning, min_due_date: datetime|None = None,
                                  # the next two are for initialization from a previous optimization run
                                  best_solution: ProductionPlanning[P] | None = None, history: list[float] | None = None,
                                  performance_models: list[PlantPerformanceModel] | None = None,
                                  parameters: dict[str, any] | None = None
                                  ) -&gt; LotsOptimizer:
        raise Exception("not implemented")</code></pre>
              </details>



  <div class="doc doc-children">









<div class="doc doc-object doc-function">


<h2 id="dynreact.base.LotsOptimizer.LotsOptimizationAlgo.__init__" class="doc doc-heading">
            <code class="highlight language-python">__init__(site)</code>

</h2>


    <div class="doc doc-contents ">

            <details class="quote">
              <summary>Source code in <code>dynreact\base\LotsOptimizer.py</code></summary>
              <pre class="highlight"><code class="language-python">def __init__(self, site: Site):
    self._site = site</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="dynreact.base.LotsOptimizer.LotsOptimizationAlgo.heuristic_solution" class="doc doc-heading">
            <code class="highlight language-python">heuristic_solution(process, snapshot, planning_horizon, costs, targets, orders, start_orders=None)</code>

</h2>


    <div class="doc doc-contents ">

        <p>If orders is not specified, this method will only consider as many orders for scheduling as are required to
fulfill the targets per plant. Otherwise unassigned orders may occur.</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>process</code></b>
                  (<code>str</code>)
              –
              <div class="doc-md-description">
                
              </div>
            </li>
            <li>
              <b><code>snapshot</code></b>
                  (<code><a class="autorefs autorefs-internal" title="dynreact.base.model.Snapshot" href="model.html#dynreact.base.model.Snapshot">Snapshot</a></code>)
              –
              <div class="doc-md-description">
                
              </div>
            </li>
            <li>
              <b><code>planning_horizon</code></b>
                  (<code><span title="datetime.timedelta">timedelta</span></code>)
              –
              <div class="doc-md-description">
                
              </div>
            </li>
            <li>
              <b><code>costs</code></b>
                  (<code><a class="autorefs autorefs-internal" title="dynreact.base.CostProvider.CostProvider" href="cost_provider.html#dynreact.base.CostProvider.CostProvider">CostProvider</a></code>)
              –
              <div class="doc-md-description">
                
              </div>
            </li>
            <li>
              <b><code>targets</code></b>
                  (<code><a class="autorefs autorefs-internal" title="dynreact.base.model.ProductionTargets" href="model.html#dynreact.base.model.ProductionTargets">ProductionTargets</a></code>)
              –
              <div class="doc-md-description">
                
              </div>
            </li>
            <li>
              <b><code>orders</code></b>
                  (<code>list[str]</code>)
              –
              <div class="doc-md-description">
                
              </div>
            </li>
            <li>
              <b><code>start_orders</code></b>
                  (<code>dict[int, str] | None</code>, default:
                      <code>None</code>
)
              –
              <div class="doc-md-description">
                <p>keys: plant id, values: order</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Returns:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
                  <code>tuple[<a class="autorefs autorefs-internal" title="dynreact.base.model.ProductionPlanning" href="model.html#dynreact.base.model.ProductionPlanning">ProductionPlanning</a>, <a class="autorefs autorefs-internal" title="dynreact.base.model.ProductionTargets" href="model.html#dynreact.base.model.ProductionTargets">ProductionTargets</a>]</code>
              –
              <div class="doc-md-description">
                
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
            <details class="quote">
              <summary>Source code in <code>dynreact\base\LotsOptimizer.py</code></summary>
              <pre class="highlight"><code class="language-python">def heuristic_solution(self, process: str, snapshot: Snapshot, planning_horizon: timedelta, costs: CostProvider,
                       targets: ProductionTargets, orders: list[str], start_orders: dict[int, str]|None=None) -&gt; tuple[ProductionPlanning, ProductionTargets]:
    """
    If orders is not specified, this method will only consider as many orders for scheduling as are required to
    fulfill the targets per plant. Otherwise unassigned orders may occur.
    :param process:
    :param snapshot:
    :param planning_horizon:
    :param costs:
    :param targets:
    :param orders:
    :param start_orders: keys: plant id, values: order
    :return:
    """
    # We remove orders from this dict as they are assigned to plants
    order_objects: dict[str, Order] = {order.id: order for order in snapshot.orders if order.id in orders}
    # for faster access, remember assigned orders
    orders_done: dict[str, Order] = {}
    # We remove plants from this list as soon as there are no more orders available for them (by checking available_tons_per_plant[plant] &gt; 0)
    plants: dict[int, Equipment] = {p.id: p for p in self._site.get_process_equipment(process) if p.id in targets.target_weight}
    #assignments: dict[str, int] = {}
    assignments_by_plant: dict[int, list[str]] = {p: [] for p in plants.keys()}
    plant_weights: dict[int, float] = {}
    if start_orders is None:
        start_orders = {}
    # Here we keep track of available tons (from as yet unassigned orders) per plant
    available_tons_by_plant: dict[int, float] = {p: 0 for p in plants.keys()}
    # here we keep track of how many tons are still missing per plant
    missing_tons_by_plant: dict[int, float] = {p: targets.target_weight[p].total_weight for p in plants.keys()}
    for order in order_objects.values():
        orders_plants = [p for p in plants.keys() if p in order.allowed_equipment]
        for p in orders_plants:
            available_tons_by_plant[p] += order.actual_weight
            # TODO better initialization algo?

    def assign_to_plant(o: Order, plant: int):
        assignments_by_plant[plant].append(o.id)
        order_objects.pop(o.id)
        orders_done[o.id] = o
        missing_tons_by_plant[plant] = missing_tons_by_plant[plant] - o.actual_weight
        for other_plant in o.allowed_equipment:
            if other_plant in available_tons_by_plant:
                available_tons_by_plant[other_plant] = available_tons_by_plant[other_plant] - o.actual_weight

    for plant in [p for p in plants.keys() if p not in start_orders]:
        random_order: Order | None = next((o for o in order_objects.values() if plant in o.allowed_equipment), None)
        if random_order is not None:
            start_orders[plant] = random_order.id
            assign_to_plant(random_order, plant)
        else:
            plants.pop(plant)
    # The main loop
    while len(plants) &gt; 0 and len(order_objects) &gt; 0:
        diff_by_plant: dict[int, float] = {p: available_tons_by_plant[p] - missing_tons_by_plant[p] for p in plants.keys()}
        plant: int = min(diff_by_plant, key=diff_by_plant.get) # the plant most in need of more orders
        if available_tons_by_plant[plant] &lt; 0.00001:
            plants.pop(plant)
            continue
        plant_obj: Equipment = plants[plant]
        current_order: str = assignments_by_plant[plant][-1] if len(assignments_by_plant[plant]) &gt; 0 else start_orders[plant]
        current_order_obj: Order = orders_done[current_order] if current_order in orders_done else snapshot.get_order(current_order, do_raise=True)
        # applicable_orders = {oid: order for oid, order in order_objects.items() if plant in order.allowed_plants}
        transition_costs: dict[str, float] = \
            {oid: costs.transition_costs(plant_obj, current_order_obj, order) for oid, order in order_objects.items() if plant in order.allowed_equipment}
        applicable_orders_cnt: int = len(transition_costs)
        transition_costs: dict[str, float] = {oid: cost for oid, cost in transition_costs.items() if np.isfinite(cost)}
        if len(transition_costs) == 0:  # ideally this should not happen
            if applicable_orders_cnt &gt; 0:
                print("No valid transition to a new order found for plant", plant.id, "out of", applicable_orders_cnt, "applicable orders")
            plants.pop(plant)
            continue
        lowest_transition_order: str = min(transition_costs, key=transition_costs.get)
        assign_to_plant(order_objects[lowest_transition_order], plant)
        if missing_tons_by_plant[plant] &lt; 0.01:  # TODO configurable threshold
            plants.pop(plant)
    # keys: orders, values: plants
    assignments: dict[str, int] = {order: plant for plant, orders in assignments_by_plant.items() for order in orders}

    instance = self._create_instance_internal(process, snapshot, targets, costs, None)
    plant_lots: dict[int, list[Lot]] = instance.assign_lots(assignments)
    order_assignments: dict[str, OrderAssignment] = {}
    for order, plant in assignments.items():
        if plant not in plant_lots:
            continue
        lots = plant_lots[plant]
        lot: Lot | None = next((lot for lot in lots if order in lot.orders), None)
        if lot is None:
            continue
        order_assignments[order] = OrderAssignment(order=order, equipment=plant, lot=lot.id,
                                                   lot_idx=lot.orders.index(order) + 1)
    if orders is not None:
        unassigned: Sequence[str] = (order for order in orders if order not in assignments)
        order_assignments.update(
            {order: OrderAssignment(order=order, equipment=-1, lot="", lot_idx=-1) for order in unassigned})
    planning = costs.evaluate_order_assignments(process, order_assignments, targets=targets, snapshot=snapshot)
    return planning, targets</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="dynreact.base.LotsOptimizer.LotsOptimizationAlgo.due_dates_solution" class="doc doc-heading">
            <code class="highlight language-python">due_dates_solution(process, snapshot, planning_horizon, costs, targets=None, orders=None, include_inactive_lots=False)</code>

</h2>


    <div class="doc doc-contents ">

        <p>If orders is not specified, this method will only consider as many orders for scheduling as are required to
fulfill the targets per plant. Otherwise unassigned orders may occur.</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>process</code></b>
                  (<code>str</code>)
              –
              <div class="doc-md-description">
                
              </div>
            </li>
            <li>
              <b><code>snapshot</code></b>
                  (<code><a class="autorefs autorefs-internal" title="dynreact.base.model.Snapshot" href="model.html#dynreact.base.model.Snapshot">Snapshot</a></code>)
              –
              <div class="doc-md-description">
                
              </div>
            </li>
            <li>
              <b><code>planning_horizon</code></b>
                  (<code><span title="datetime.timedelta">timedelta</span></code>)
              –
              <div class="doc-md-description">
                
              </div>
            </li>
            <li>
              <b><code>costs</code></b>
                  (<code><a class="autorefs autorefs-internal" title="dynreact.base.CostProvider.CostProvider" href="cost_provider.html#dynreact.base.CostProvider.CostProvider">CostProvider</a></code>)
              –
              <div class="doc-md-description">
                
              </div>
            </li>
            <li>
              <b><code>targets</code></b>
                  (<code><a class="autorefs autorefs-internal" title="dynreact.base.model.ProductionTargets" href="model.html#dynreact.base.model.ProductionTargets">ProductionTargets</a> | None</code>, default:
                      <code>None</code>
)
              –
              <div class="doc-md-description">
                
              </div>
            </li>
            <li>
              <b><code>orders</code></b>
                  (<code>list[str] | None</code>, default:
                      <code>None</code>
)
              –
              <div class="doc-md-description">
                
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Returns:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
                  <code>tuple[<a class="autorefs autorefs-internal" title="dynreact.base.model.ProductionPlanning" href="model.html#dynreact.base.model.ProductionPlanning">ProductionPlanning</a>, <a class="autorefs autorefs-internal" title="dynreact.base.model.ProductionTargets" href="model.html#dynreact.base.model.ProductionTargets">ProductionTargets</a>]</code>
              –
              <div class="doc-md-description">
                
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
            <details class="quote">
              <summary>Source code in <code>dynreact\base\LotsOptimizer.py</code></summary>
              <pre class="highlight"><code class="language-python">def due_dates_solution(self, process: str, snapshot: Snapshot, planning_horizon: timedelta, costs: CostProvider,
                       targets: ProductionTargets|None = None, orders: list[str] | None = None,
                       include_inactive_lots: bool=False) -&gt; tuple[ProductionPlanning, ProductionTargets]:
    """
    If orders is not specified, this method will only consider as many orders for scheduling as are required to
    fulfill the targets per plant. Otherwise unassigned orders may occur.
    :param process:
    :param snapshot:
    :param planning_horizon:
    :param costs:
    :param targets:
    :param orders:
    :return:
    """
    if targets is None:  # TODO long term planning targets?
        _, targets = self.snapshot_solution(process, snapshot, planning_horizon, None, include_inactive_lots=include_inactive_lots)
    orders_sorted: list[Order] = sorted([o for o in snapshot.orders if o.due_date is not None and
                                         (orders is None or o.id in orders)], key=lambda order: order.due_date)
    #assignments: dict[str, OrderAssignment] = {}
    assignments: dict[str, int] = {}
    plant_weights: dict[int, float] = {}
    plants: list[int] = [p.id for p in self._site.get_process_equipment(process) if p.id in targets.target_weight]
    for order in orders_sorted:
        # TODO filter orders eligible for the current process stage =&gt; non-trivial!
        next_eligible_plant: int|None = next((p for p in order.allowed_equipment if p in plants and
                                              (p not in plant_weights or (p in targets.target_weight and plant_weights[p] &lt; targets.target_weight[p].total_weight))), None)
        if next_eligible_plant is None:
            # TODO check if all plant target weights are already exhausted, then break
            continue
        if next_eligible_plant not in plant_weights:
            plant_weights[next_eligible_plant] = 0
        plant_weights[next_eligible_plant] = plant_weights[next_eligible_plant] + order.actual_weight
        assignments[order.id] = next_eligible_plant # OrderAssignment(order=order.id, plant=next_eligible_plant, lot=..., lot_idx=...)
    instance = self._create_instance_internal(process, snapshot, targets, costs, None)
    plant_lots: dict[int, list[Lot]] = instance.assign_lots(assignments)
    order_assignments: dict[str, OrderAssignment] = {}
    for order, plant in assignments.items():
        if plant not in plant_lots:
            continue
        lots = plant_lots[plant]
        lot: Lot|None = next((lot for lot in lots if order in lot.orders), None)
        if lot is None:
            continue
        order_assignments[order] = OrderAssignment(order=order, equipment=plant, lot=lot.id, lot_idx=lot.orders.index(order)+1)
    if orders is not None:
        unassigned: Sequence[str] = (order for order in orders if order not in assignments)
        order_assignments.update({order: OrderAssignment(order=order, equipment=-1, lot="", lot_idx=-1) for order in unassigned})
    planning = costs.evaluate_order_assignments(process, order_assignments, targets=targets, snapshot=snapshot)
    return planning, targets</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="dynreact.base.LotsOptimizer.LotsOptimizationAlgo.create_instance" class="doc doc-heading">
            <code class="highlight language-python">create_instance(process, snapshot, cost_provider, targets=None, initial_solution=None, min_due_date=None, orders=None, best_solution=None, history=None, performance_models=None, parameters=None, include_inactive_lots=False)</code>

</h2>


    <div class="doc doc-contents ">

            <details class="quote">
              <summary>Source code in <code>dynreact\base\LotsOptimizer.py</code></summary>
              <pre class="highlight"><code class="language-python">def create_instance(self, process: str, snapshot: Snapshot, cost_provider: CostProvider,
                    targets: ProductionTargets | None = None, initial_solution: ProductionPlanning | None = None,
                    min_due_date: datetime|None = None,
                    # optionally, specify the orders to be planned explicitly
                    # TODO option to specify the urgency(?)
                    orders: list[str]|None = None,
                    # the next two are for initialization from a previous optimization run
                    best_solution: ProductionPlanning[P] | None = None, history: list[float] | None = None,
                    performance_models: list[PlantPerformanceModel] | None = None,
                    parameters: dict[str, any] | None = None,
                    include_inactive_lots: bool = False
                    ) -&gt; LotsOptimizer:
    if initial_solution is None or targets is None:
        planning_horizon = targets.period[1] - targets.period[0] if targets is not None else timedelta(hours=8)  # XXX?
        initial_solution0, targets0 = self.snapshot_solution(process, snapshot, planning_horizon, cost_provider, targets=targets,
                                                             orders=orders, include_inactive_lots=include_inactive_lots)
        if initial_solution is None:
            initial_solution = initial_solution0
        if targets is None:
            targets = targets0
    return self._create_instance_internal(process, snapshot, targets, cost_provider, initial_solution, min_due_date=min_due_date,
                                          best_solution=best_solution, history=history, parameters=parameters, performance_models=performance_models)</code></pre>
            </details>
    </div>

</div>



  </div>

    </div>

</div>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="cost_provider.html" class="btn btn-neutral float-left" title="Cost provider"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="model.html" class="btn btn-neutral float-right" title="Model">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="cost_provider.html" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="model.html" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script src="js/jquery-3.6.0.min.js"></script>
    <script>var base_url = ".";</script>
    <script src="js/theme_extra.js"></script>
    <script src="js/theme.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
